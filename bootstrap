#!/bin/bash
#
# bootstrap files to its places.
#

SCRIPT_NAME="$0"
DOTFILES_ROOT="`pwd`"
MAX_DEPTH=3

set -e
echo ''

usage () {
  # Prints usage of the script
  echo "Usage: $SCRIPT_NAME" 1>&2;
  exit 1;
}

# Parse command line arguments
# Use > 1 to consume two arguments per pass in the loop (e.g. each argument has
# a corresponding value to go with it). Use > 0 to consume one or more arguments
# per pass in the loop (e.g. some arguments don't have a corresponding value to
# go with it).
while [[ $# > 0 ]]
do
  key="$1"

  case $key in
    -f|--force)
      force=true
      shift # past argument
      ;;
    -o|--overwrite)
      force=true
      shift # past argument
      ;;
    -h|--help)
      usage
      shift # past argument
      ;;
    -v|--verbose)
      verbose=true
      shift # past argument
      ;;
    -r|--remove)
      removebrokenlinks
      exit 1
      shift # past argument
      ;;
    *)
      # No options
      ;;
  esac
  shift # past argument or value
done

removebrokenlinks() {
  # Remove broken links from HOME directory
  if [[ "$verbose" == true ]]; then
    echo "*** Removing broken symlinks from $HOME ***"
  fi
  find $HOME -maxdepth 1 -name ".*" -type l | while read f; do if [ ! -e "$f"  ]; then rm -f "$f"; fi; done
}
info () {
    printf "\r\033[0;34m$1\033[0m\n"
}
user () {
    printf "\r  [ \033[0;33m?\033[0m ] $1 "
}
success () {
    printf "\r\033[2K  [\033[0;32m  OK  \033[0m] $1\n"
}
fail () {
    printf "\r\033[2K  [\033[0;31mFAIL\033[0m] $1\n"
    echo ''
    exit
}
link_file () {
  local SOURCE=$1 DESTINATION=$2
  local FORCE= BACKUP= SKIP=
  local ACTION=
  if [ -f "$DESTINATION" -o -d "$DESTINATION" -o -L "$DESTINATION" ]
  then
    if [ "$FORCE_ALL" == "false" ] && [ "$BACKUP_ALL" == "false" ] && [ "$SKIP_ALL" == "false" ]
    then
      local CURR_SOURCE="$(readlink $DESTINATION)"

      if [ "$CURR_SOURCE" == "$SOURCE" ]
      then
        SKIP=true;
      else
        user "File already exists: $DESTINATION ($(basename "$SOURCE")), what do you want to do?\n\
        [s]kip, [S]kip all, [o]verwrite, [O]verwrite all, [b]ackup, [B]ackup all?"
        read -n 1 action

        case "$action" in
          o )
            FORCE=true;;
          O )
            FORCE_ALL=true;;
          b )
            BACKUP=true;;
          B )
            BACKUP_ALL=true;;
          s )
            SKIP=true;;
          S )
            SKIP_ALL=true;;
          * )
            ;;
        esac
      fi
    fi
    FORCE=${FORCE:-$FORCE_ALL}
    BACKUP=${BACKUP:-$BACKUP_ALL}
    SKIP=${SKIP:-$SKIP_ALL}
    if [ "$FORCE" == "true" ]
    then
      rm -rf "$DESTINATION"
      success "removed $DESTINATION"
    fi
    if [ "$BACKUP" == "true" ]
    then
      mv "$DESTINATION" "${DESTINATION}.backup"
      success "moved $DESTINATION to ${DESTINATION}.backup"
    fi
    if [ "$SKIP" == "true" ]
    then
      success "skipped $SOURCE"
    fi
  fi
  if [ "$SKIP" != "true" ]  # "false" or empty
  then
    ln -s "$1" "$2"
    success "linked $1 to $2"
  fi
}

# Symlink *.symlink files to $HOME
install_dotfiles () {
  info 'installing dotfiles'

  local FORCE_ALL=false BACKUP_ALL=false SKIP_ALL=false

  for SOURCE in $(find -H "$DOTFILES_ROOT" -maxdepth $MAX_DEPTH -name '*.symlink' -not -path '*.git*')
  do
    DESTINATION="$HOME/.$(basename "${SOURCE%.*}")"
    link_file "$SOURCE" "$DESTINATION"
  done
}

install_dotfiles

echo ''
printf "\033[0;31mDone!\033[0m \n"

# vim: set fdm=marker fmr={,} ft=sh:
