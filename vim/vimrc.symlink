"
" vct's dotfiles: https://gitlab.com/padawanphysicist/dotfiles
"
" vim configuration
"

" Vundle Configuration { 
"
" Vundle is a very nice plug-in manager for Vim. It has the same principles as
" Pathogen (https://github.com/tpope/vim-pathogen/) but with a
" Git-GitHub-aware management system. Vundle is available at
"
" https://github.com/gmarik/Vundle.vim
"
set nocompatible                  " Be iMproved (required)
filetype off                      " Required

set rtp+=~/.vim/bundle/Vundle.vim " Set the runtime path to include Vundle
call vundle#begin()               " Initialize Vundle

" alternatively, pass a path where Vundle should install plugins
"call vundle#begin('~/some/path/here')

Plugin 'gmarik/Vundle.vim'   " let Vundle manage Vundle (required)
Plugin 'tpope/vim-markdown'  
Plugin 'nanotech/jellybeans.vim' " Colorful, dark scheme

" All of your Plugins must be added before the following line
call vundle#end()            " Required
filetype plugin indent on    " Required

" }
" General Settings {

" To sharpen Vim's memory and smartness, we can keep a ~/.viminfo file. This
" file keeps some useful data, like history searches (/), commands (:), tags
" (`), registers, etc. With this file it's also possible to to copy a line (yy), 
" quit the file, open a new one and then paste (p) that line you previously
" copied.
set viminfo='10,\"30,:20,%,n~/.viminfo

" This set the cursor at the position it was since the last time you opened the 
" file
au BufReadPost * if line("'\"")|execute("normal `\"")|endif

" Show useless whitespaces in the end of the lines
au BufNewFile,BufRead * match Error '\s\+$'

" Show hidden characters
" set list

" These are very handy command-line abbreviations
cab W  w
cab Wq wq
cab wQ wq
cab WQ wq
cab Q  q
cab E  e

" Show/Hide comments
fu! CommOnOff()
    if !exists('g:hiddcomm')
        let g:hiddcomm=1 | hi Comment ctermfg=black guifg=black
    else
        unlet g:hiddcomm | hi Comment ctermfg=cyan  guifg=cyan term=bold
    endif
endfu
map <F12> :call CommOnOff()<cr>

" Remove espaços redundantes no fim das linhas fiz uma adição ao comando
" depois do <esc> mz cria uma marca para voltar ao ponto em que se está e 'z
" retorna a este ponto ao final do comando
map <F7> <esc>mz:%s/\s\+$//g<cr>`z

set t_Co=256           " Enable 256 colors
syntax enable          " Turn on syntax highlighting
colorscheme jellybeans " Choose colorscheme

set number  " Show line numbers
set mouse=a " Enable mouse on all modes

set cursorline " Highlight current line
set history=10000 " Sets how many lines of history VIM has to remember

set nobk          " Turn backup off, since most stuff is in git anyway...
set nowb          " Prevents automatic backup
set wildignore=*.o,*.obj,*.bak,*.exe,*.x " These files must be ignored by VIM

" Textual search options {
set ignorecase    " Case-insensitive search
set smartcase     " With this option, a search is case-insensitive if
                  " you enter the search string in ALL lower case
set hlsearch      " Highlight search
set incsearch     " Incremental search
" }

" Set utf8 as standard encoding and en_US as the standard language
set encoding=utf8 

" No noise from VIM! {
    set noerrorbells " No beeping!
    set hidden       " Hides buffers instead of close them
" }

set autoread " Set to auto read when a file is changed from the outside

set laststatus=2 " Always display the statusline

" Fixing the delay in exiting visual/insert mode {
set timeout " Do time out on mappings and others
set timeoutlen=2000 " Wait {num} ms before timing out a mapping
" When you’re pressing Escape to leave insert mode in the terminal, it will by
" default take a second or another keystroke to leave insert mode completely
" and update the statusline. This fixes that. I got this from:
" https://powerline.readthedocs.org/en/latest/tipstricks.html#vim
if !has('gui_running')
    set ttimeoutlen=10
    augroup FastEscape
        autocmd!
        au InsertEnter * set timeoutlen=0
        au InsertLeave * set timeoutlen=1000
    augroup END
endif
" }

" Moving between screen lines {
" To use in line wrapping; when you do soft line breaking, moving the cursor
" up and down will jump from one physical line to another; to move between
" displayed lines, you must press gj and gk, and this is really annoying!
"
" Although one can do the simple mapping
"
"    imap <silent> <Down> <C-o>gj
"    imap <silent> <Up> <C-o>gk
"    nmap <silent> <Down> gj
"    nmap <silent> <Up> gk
"
" this actually breaks VIM's omnicompletion. The function below was found in
"
" <http://vim.wikia.com/wiki/Move_cursor_by_display_lines_when_wrapping>
"
" to be a nice solution for this problem.
function! NoremapNormalCmd(key, preserve_omni, ...)
  let cmd = ''
  let icmd = ''
  for x in a:000
    let cmd .= x
    let icmd .= "<C-\\><C-O>" . x
  endfor
  execute ":nnoremap <silent> " . a:key . " " . cmd
  execute ":vnoremap <silent> " . a:key . " " . cmd
  if a:preserve_omni
    execute ":inoremap <silent> <expr> " . a:key . " pumvisible() ? \"" . a:key . "\" : \"" . icmd . "\""
  else
    execute ":inoremap <silent> " . a:key . " " . icmd
  endif
endfunction

" Cursor moves by screen lines
call NoremapNormalCmd("<Up>", 1, "gk")
call NoremapNormalCmd("<Down>", 1, "gj")
call NoremapNormalCmd("<Home>", 0, "g<Home>")
call NoremapNormalCmd("<End>", 0, "g<End>")
" }

" Clear last search pattern by hitting return
nnoremap <CR> :noh<CR><CR>

" Text formatting {
    set wrap linebreak nolist " do soft word wrap
    set shiftwidth=4 " Adjust the number of columns shifted by commands < or >
    " Space vs TAB {
        set expandtab " Use spaces instead of TABs
        set tabstop=4 " Each TAB has four spaces
        set softtabstop=4 " Let backspace delete indent
    " }
    set encoding=utf8 " Set utf8 as standard encoding and en_US as the standard language
" }

" }
" Specific Filetype Configuration {

" Makes Vim recognize Julia language files
au BufNewFile,BufRead *.jl,*.julia set filetype=julia

" .tex, .sty and .cls files are always LaTeX files
au BufNewFile,BufRead *.tex,*.sty,*.cls set filetype=tex 

" Bash files
au BufNewFile,BufRead *.sh,*.bash set filetype=sh 

" }

" vim: set fdm=marker fmr={,}:
